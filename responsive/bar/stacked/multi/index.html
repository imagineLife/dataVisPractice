<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>MultiStackedBar</title>
    <style>
      #chart {
        position: absolute;
        left: 0px;
        right: 0px;
        top: 0px;
        bottom: 0px;
      }
      .domain {
        display: none;
      }
      .tick line {
        stroke: #C0C0BB;
      }    
    </style>
  </head>
  <body>
    <div id="chart"></div>
  </body>
  <!-- <script src="//d3js.org/d3.v4.min.js"></script> -->
  <script src="../../../../d3.v4.min.js"></script>
  <script src="../../../../d3-selection-multi.min.js"></script>
  <script>

    // Build Variables
    const vars = {
      xLabel : 'Note Name',
      yLabel : 'Number Of Notes',
      margin : { left: 50, right: 70, top: 40, bottom: 110 }
    };

    //Add nodes to D3 selections
    const chartDiv = document.getElementById("chart");
    const svgObj = d3.select(chartDiv).append("svg");
    const width = +600 - vars.margin.left - vars.margin.right;
    const height = +500 - vars.margin.top - vars.margin.bottom;
    const gObj = svgObj.append("g");

    //build d3 scales
    const xScale = d3.scaleBand()
        .padding(0.3)
        .align(0.3);
    const yScale = d3.scaleLinear();
    const colorScale = d3.scaleOrdinal(d3.schemeCategory20);

    // Extract the width and height that was computed by CSS.
    let resizedWidth = chartDiv.clientWidth;
    let resizedHeight = chartDiv.clientHeight;

    //calcualte dimensions less margins
    let heightLessMargins = resizedHeight - vars.margin.top - vars.margin.bottom;
    let widthLessMargins = resizedWidth - vars.margin.left - vars.margin.right;


    //declare axis g vars
    const xAxisG = gObj.append("g")
      .attrs({
        "class": "axis axis--x",
        "transform": "translate(0," + heightLessMargins + ")"
      });

    const yAxisG = gObj.append("g")
      .attr("class", "axis axis--y");


    //set svg height & width
    svgObj.attrs({
      "width" : resizedWidth,
      "height" : resizedHeight
    });

    //transform the g obj
    gObj.attr("transform", "translate(" + vars.margin.left + "," + vars.margin.top + ")");

    const stack = d3.stack();


    // X-AXIS & Y-AXIS
    //via D3
    const xAxisD3 = d3.axisBottom()
      .scale(xScale)
      .tickPadding(15)
      .tickSize(-heightLessMargins);

    const yAxisD3 = d3.axisLeft()
      .scale(yScale)
      .ticks(10) //yTicks as 10 later, perhaps
      .tickPadding(15)
      // .tickFormat(10, "s")
      .tickSize(-widthLessMargins);

    d3.csv("data.csv", type, function(error, data) {
      if (error) throw error;

      data.sort(function(a, b) { return b.totalOfThisCategory - a.totalOfThisCategory; });

      xScale.domain(data.map(function(d) { return d.ethnicity; }));
      yScale.domain([0, d3.max(data, function(d) { return d.totalOfThisCategory; })]).nice();
      colorScale.domain(data.columns.slice(1));

      gObj.selectAll(".serie")
        .data(stack.keys(data.columns.slice(1))(data))
        .enter().append("g")
          .attrs({
            "class": "serie",
            "fill": function(d) { return colorScale(d.key); }
          })
        .selectAll("rect")
        .data(function(d) { return d; })
        .enter().append("rect")
          .attrs({
            "x": function(d) { return xScale(d.data.ethnicity); },
            "y": function(d) { return yScale(d[1]); },
            "height": function(d) { return yScale(d[0]) - yScale(d[1]); },
            "width": xScale.bandwidth()
          });

      xAxisG
        .call(xAxisD3)
        .selectAll('.tick line').remove();

        yAxisG
          .call(yAxisD3)
        .append("text")
          .attrs({
            "x": 2,
            "y": yScale(yScale.ticks(10).pop()),
            "dy": "0.35em",
            "text-anchor": "start",
            "fill": "#000"
          })
          .text("Population");

      // const legend = gObj.selectAll(".legend")
      //   .data(data.columns.slice(1).reverse())
      //   .enter().append("g")
      //     .attrs({
      //       "class": "legend",
      //       "transform": function(d, i) { return "translate(0," + i * 20 + ")"; }
      //     })
      //     .style("font", "10px sans-serif");

      // legend.append("rect")
      //     .attrs({
      //       "x": width + 18,
      //       "width": 18,
      //       "height": 18,
      //       "fill": z
      //     })

      // legend.append("text")
      //     .attrs({
      //       "x": width + 44,
      //       "y": 9,
      //       "dy": ".35em",
      //       "text-anchor": "start"
      //     })
      //     .text(function(d) { return d; });
    });

    function type(d, i, columns) {
      //columns are the column header row

      for (i = 1, t = 0; i < columns.length; ++i){
        t += d[columns[i]] = +d[columns[i]];
      }

      d.totalOfThisCategory = t;
      return d;
    }

    let resize = () => {
      console.log('resizing!');

      // Extract the width and height that was computed by CSS.
      let resizedFnWidth = chartDiv.clientWidth;
      let resizedFnHeight = chartDiv.clientHeight;

      let resizedWidthLessMargins = resizedFnWidth - vars.margin.left - vars.margin.right;
      let resizedHeightLessMargins = resizedFnHeight - vars.margin.top - vars.margin.bottom;

      svgObj.attrs({
        "width" : resizedFnWidth,
        "height" : resizedFnHeight
      });
    
      //set xScale
      xScale.rangeRound([0, resizedWidthLessMargins])

      //set yScale
      yScale.rangeRound([resizedHeightLessMargins, vars.margin.top]);

      //Update the X-AXIS
      xAxisG
        .attrs({
            'transform': `translate(0, ${resizedHeightLessMargins})`,
            'x' : widthLessMargins / 2,
            'y' : resizedHeight * .1,
        })
        .call(xAxisD3);

      //Update the Y-AXIS
      yAxisG
        .attrs({
            'x' : -resizedHeightLessMargins / 2,
            'y' : -vars.margin.left / 2,
        })
        .call(yAxisD3);

    }

    d3.select(window).on('resize',resize);

    resize();
  </script>
  </body>
</html>