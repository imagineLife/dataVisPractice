<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>MultiStackedBar</title>
    <style>
      #chart {
        position: absolute;
        left: 0px;
        right: 0px;
        top: 0px;
        bottom: 0px;
      }
      .domain {
        display: none;
      }
      .tick line {
        stroke: #C0C0BB;
      }
      .axis-label {
        fill: #635F5D;
        font-size: 20pt;
        font-family: sans-serif;
      }
      .toolTip {
        position: absolute;
        display: none;
        min-width: 80px;
        height: auto;
        background: none repeat scroll 0 0 rgba(255,255,255,.7);
        padding: 14px;
        text-align: center;
        font-size: 20px;
        font-family: sans-serif;
      }      
    </style>
  </head>
  <body>
    <div id="chart"></div>
  </body>
  <!-- <script src="//d3js.org/d3.v4.min.js"></script> -->
  <script src="../../../../d3.v4.min.js"></script>
  <script src="../../../../d3-selection-multi.min.js"></script>
  <script>

    // Build Variables
    const vars = {
      xLabel : 'City',
      yLabel : 'Population',
      margin : { left: 120, right: 70, top: 40, bottom: 110 },
    };

    //Add nodes to D3 selections
    const chartDiv = document.getElementById("chart");
    const svgObj = d3.select(chartDiv).append("svg");
    const width = +600 - vars.margin.left - vars.margin.right;
    const height = +500 - vars.margin.top - vars.margin.bottom;
    const gObj = svgObj.append("g");

    //Tooltip
    const tooltipDiv = d3.select("body").append("div").attr("class", "toolTip");

    //build d3 scales
    const xScale = d3.scaleBand()
        .padding(0.3)
        .align(0.3);
    const yScale = d3.scaleLinear();
    const colorScale = d3.scaleOrdinal(d3.schemeCategory20);

    // Extract the width and height that was computed by CSS.
    let resizedWidth = chartDiv.clientWidth;
    let resizedHeight = chartDiv.clientHeight;

    //calcualte dimensions less margins
    let heightLessMargins = resizedHeight - vars.margin.top - vars.margin.bottom;
    let widthLessMargins = resizedWidth - vars.margin.left - vars.margin.right;


    //declare axis g vars
    const xAxisG = gObj.append("g")
      .attrs({
        "class": "axis axis--x",
        "transform": "translate(0," + heightLessMargins + ")"
      });

    const yAxisG = gObj.append("g")
      .attr("class", "axis axis--y");

    //axis titles
    let yAxisLabel = yAxisG.append('text');
    let xAxisLabel = xAxisG.append('text');

    xAxisLabel
      .attrs({
        'class' :'x axis-label',
        'x' : widthLessMargins / 2,
        'y' : resizedHeight * .1
      })
      .text(vars.xLabel);

    yAxisLabel.attrs({
      'class' : 'y axis-label',
      'x' : -heightLessMargins / 2,
      'y' : -vars.margin.left / 1.75,
      'transform' : `rotate(-90)`
    })
    .style('text-anchor', 'middle')
    .text(vars.yLabel);

    //set svg height & width
    svgObj.attrs({
      "width" : resizedWidth,
      "height" : resizedHeight
    });

    //transform the g obj
    gObj.attr("transform", "translate(" + vars.margin.left + "," + vars.margin.top + ")");

    const stack = d3.stack();


    // X-AXIS & Y-AXIS
    //via D3
    const xAxisD3 = d3.axisBottom()
      .scale(xScale)
      .tickPadding(15)
      .tickSize(-heightLessMargins);

    const yAxisD3 = d3.axisLeft()
      .scale(yScale)
      .ticks(10) //yTicks as 10 later, perhaps
      .tickPadding(15)
      // .tickFormat(10, "s")
      .tickSize(-widthLessMargins);

    d3.csv("data.csv", type, (error, data) => {
      if (error) throw error;

      data.sort((a, b) =>  b.totalOfThisCategory - a.totalOfThisCategory );

      xScale.domain(data.map((d) =>  d.geo));
      yScale.domain([0, d3.max(data, (d) => d.totalOfThisCategory )]).nice();
      colorScale.domain(data.columns.slice(1));

      gObj.selectAll(".seriesClass")
        .data(stack.keys(data.columns.slice(1))(data))
        .enter().append("g")
          .attrs({
            "class": "seriesClass",
            "fill": (d) => colorScale(d.key)
          })
        .selectAll("rect")
        .data((d) => d )
        .enter().append("rect")
          .attrs({
            "x": (d) => xScale(d.data.geo),
            "y": (d) => yScale(d[1]),
            "height": (d) => yScale(d[0]) - yScale(d[1]),
            "width": xScale.bandwidth(),
            "class":'singleRect'
          })
          .on("mousemove", function(d){
            const rectData = d.data,
              rectVal = d[1] - d[0];
            let rectKey = filterObj(rectData, rectVal);
            tooltipDiv
              .style("left", d3.event.pageX - 150 +  "px")
              .style("top", d3.event.pageY - 150 + "px")
              .style("display", "inline-block")
              .html(`<b>${d.data.geo}</b><br>`+
                `Age Range: <b>${rectKey}</b><br>`+
                `Population: <b>${rectVal}</b>`);
          })
          .on("mouseout", function(d){ tooltipDiv.style("display", "none");});

      xAxisG
        .call(xAxisD3)
        .selectAll('.tick line').remove();

        yAxisG
          .call(yAxisD3)
        .append("text")
          .attrs({
            "x": 2,
            "y": yScale(yScale.ticks(10).pop()),
            "dy": "0.35em",
            "text-anchor": "start",
            "fill": "#000"
          });

        //tilt x-Axis Labels
        xAxisG.selectAll('.tick text')
          .attrs({
            'transform': 'rotate(-45)',
            'text-anchor': 'end',
            'alignment-baseline':'middle',
            'x': -5,
            'y': 15,
            'dy':0

          })

      // const legend = gObj.selectAll(".legend")
      //   .data(data.columns.slice(1).reverse())
      //   .enter().append("g")
      //     .attrs({
      //       "class": "legend",
      //       "transform": function(d, i) { return "translate(0," + i * 20 + ")"; }
      //     })
      //     .style("font", "10px sans-serif");

      // legend.append("rect")
      //     .attrs({
      //       "x": width + 18,
      //       "width": 18,
      //       "height": 18,
      //       "fill": z
      //     })

      // legend.append("text")
      //     .attrs({
      //       "x": width + 44,
      //       "y": 9,
      //       "dy": ".35em",
      //       "text-anchor": "start"
      //     })
      //     .text(function(d) { return d; });
    });

    function filterObj(obj, val){
      let result = "";
      for (key in obj){
        if(obj[key] == val) result = key;
      }
      return result
    }

    function type(d, i, columns) {
      //columns are the column header row

      for (i = 1, t = 0; i < columns.length; ++i){
        t += d[columns[i]] = +d[columns[i]];
      }

      d.totalOfThisCategory = t;
      return d;
    }

    let resize = () => {

      // Extract the width and height that was computed by CSS.
      let resizedFnWidth = chartDiv.clientWidth;
      let resizedFnHeight = chartDiv.clientHeight;
      let resizedWidthLessMargins = resizedFnWidth - vars.margin.left - vars.margin.right;
      let resizedHeightLessMargins = resizedFnHeight - vars.margin.top - vars.margin.bottom;

      svgObj.attrs({
        "width" : resizedFnWidth,
        "height" : resizedFnHeight
      });
    
      //set xScale
      xScale.rangeRound([0, resizedWidthLessMargins])

      //set yScale
      yScale.rangeRound([resizedHeightLessMargins, vars.margin.top]);

      d3.selectAll('.singleRect').attrs({
        "x": (d) => xScale(d.data.geo),
        "y": (d) => yScale(d[1]),
        "height": (d) => yScale(d[0]) - yScale(d[1]),
        "width": xScale.bandwidth()
      })

      //Update the X-AXIS
      xAxisG
        .attrs({
            'transform': `translate(0, ${resizedHeightLessMargins})`,
            'x' : resizedWidthLessMargins / 2,
            'y' : resizedHeight * .1,
        })
        .call(xAxisD3);

      //Update the Y-AXIS
      yAxisG
        .attrs({
            'x' : -resizedHeightLessMargins / 2,
            'y' : -vars.margin.left / 2,
        })
        .call(yAxisD3);

      //Update the X-AXIS LABEL
      xAxisLabel
        .attrs({
          'x' : resizedWidthLessMargins / 2,
          'y' : resizedHeight * .1
        })

      //Update yAxis Label
      yAxisLabel.attrs({
        'x' : -resizedHeightLessMargins / 2,
        'y' : -vars.margin.left / 1.75,
      });

      d3.selectAll('.tick line')
        .attr('x2', resizedWidthLessMargins);

    }

    d3.select(window).on('resize',resize);

    resize();
  </script>
  </body>
</html>