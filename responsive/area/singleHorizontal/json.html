<!DOCTYPE html>
<html>
<head>
	<title>Remix Hz Single Area</title>
	<meta charset="utf-8">
	<meta content="width=device-width" name="viewport">
	<script src="../../../d3.v4.min.js"></script>
	<script src="../../../d3-selection-multi.min.js"></script>
	<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.js"></script>  -->
	<!-- <script src="https://d3js.org/d3-selection-multi.v1.min.js"></script> -->
	<link rel="stylesheet" type="text/css" href="../../dark.css">
	<!-- <link rel="stylesheet" type="text/css" href="this.css"> -->
</head>
<body>
	<div id="chartDiv"></div>
	<script>
	         
		const xLabel = 'Date';
		const yLabel = 'Percent';

		const margin = { 
			left: 140, 
			right: 50,
			top: 50,
			bottom: 120
		};

		//Select/Create div, svg, g
		const chartDiv = document.getElementById('chartDiv');     
		const svgObj = d3.select(chartDiv).append("svg").attrs({
			'border': '2px solid green',
			'class': 'area'
		});
		const gObj = svgObj.append('g').attr('class','gWrapper');


		// Extract the DIV width and height that was computed by CSS.
		let parentDivWidth = chartDiv.clientWidth;
		let parentDivHeight = chartDiv.clientHeight;

		//get css-computed dimensions
		const divWidthLessMargins =parentDivWidth - margin.left - margin.right;
		const divHeightLessMargins = parentDivHeight - margin.top - margin.bottom;

		//set svg height & width from div computed dimensions
		//NOTE: can be the divLessMargins, for 'padding' effect
		svgObj.attrs({
			"width" : parentDivWidth,
			"height" : parentDivHeight
		});

		//translate the gWrapper
		gObj.attr('transform', `translate(${margin.left},${margin.top})`);

		//Setup Scales
		var xScale = d3.scaleUtc().range([0, divWidthLessMargins]);
		var yScale = d3.scaleLinear().range([divHeightLessMargins, 0]);
		colorScale = d3.scaleOrdinal(['rgba(255,255,255,0)', 'rgba(255, 127, 14,.4)']);
		// colorScale = d3.scaleOrdinal(['rgba(255,255,255,0)', 'rgba(255, 127, 14,1)']);

		//Build Axis Groups
		const xAxisG = gObj.append('g')
		 .attrs({
		   'transform': `translate(0, ${divHeightLessMargins})`,
		   'class':'axis x'
		 });

		const yAxisG = gObj.append('g')
		.attrs({
		   'class': 'axis y'
		});

		//set placeholder for axis labels      
		let xAxisLabel = xAxisG.append('text');
		let yAxisLabel = yAxisG.append('text');

		//set attrs for axis labels      
		xAxisLabel
		 .attrs({
		   'class': 'axis-label',
		   'x': (divWidthLessMargins / 2),
		   'y': '100'
		 })
		 .text(xLabel);

		yAxisLabel
		 .attrs({
		   'class': 'axis-label',
		   'x' : -divHeightLessMargins / 2,
		   'y' : -margin.left / 1.5,
		   'transform' : `rotate(-90)`
		 })
		 .style('text-anchor', 'middle')
		 .text(yLabel);

		//Build Axis elements
		const xAxis = d3.axisBottom()
			.scale(xScale)
			.tickPadding(15)
			.tickSize(-divHeightLessMargins);

		const yAxis = d3.axisLeft()
			.scale(yScale)
			.ticks(10)
			.tickPadding(15)
			// .tickFormat(d3.format('.2s'))
			.tickSize(-divWidthLessMargins);

		//declare the d3 stack function
		const stack = d3.stack();

		// define the area
		const areaFunction = d3.area()
			.curve(d3.curveStepBefore)
		    .x(function(d, i) { return xScale(d.data.t); })
		    .y0(function(d) { return yScale(d[0]); })
		    .y1(function(d) { return yScale( (d[1] - d[0]) ); })
		    

		// parse the date / time
		const parseTime = d3.timeParse("%Y %b %d");


	    let keysArr = [];
		let heaterRangeData = [];

		function buildChart(obj){

			d3.json(obj.dataFile, data => {

				let settingsData = data["Settings"];
				let parseTime = d3.timeParse("%Y %b %d");

				//setup settingsData
				//settingsData.map(d => {
				//	d.t = new Date(d.t);
					// for (var i = 1, n = keysArr.length; i < n; ++i){ 
					// 	d[keysArr[i]] = d[keysArr[i]];
					// }	         		
			//	})

				//setup heater-range data
				settingsData.map(d => {
					let thisObj = {
						t: new Date(d.t),
						lh: d.lh,
						hh: d.hh
					}
					heaterRangeData.push(thisObj);
				})

				//put data keys into array
				for (var key in heaterRangeData[0]){
					keysArr.push(key)
				}

				heaterRangeData.map( d => {
					for (var i = 1, n = keysArr.length; i < n; ++i){ 
							d[keysArr[i]] = d[keysArr[i]];
						}
				})
				let minHeaterVal = d3.min(heaterRangeData, (d) => d.lh);
				let maxHeaterVal = d3.max(heaterRangeData, (d) => d.hh);
				console.log('minHeaterVal -->',minHeaterVal);
				console.log('maxHeaterVal -->',maxHeaterVal);
				// console.log('heaterRangeData ->',heaterRangeData);

				//set the keys of the data
				const keys = keysArr.slice(1);

				// scale the range of the data
				xScale.domain(d3.extent(heaterRangeData, function (d) { return d.t; }));
				colorScale.domain(keys);

				//set the stack to have the keys
				stack.keys(keys);

				let stackedData = stack(heaterRangeData);
				console.log('STACKED heaterRangeData ->',stackedData);
				//update the scale ranges
				xScale
				.range([0, divWidthLessMargins]);

				yScale.domain([ (minHeaterVal * .98) , (maxHeaterVal * 1.02) ])

				yScale
				.range([divHeightLessMargins, margin.top]);
				//.nice();

				var layer = gObj.selectAll(".layer")
				.data(stackedData)
				.enter().append("g")
				.attr("class", "layer");

				layer.append("path")
				.attr("class", "area")
				.style("fill", function(d) { return colorScale(d.key); })
				.attr("d", areaFunction);

				layer.filter(function(d) { return d[d.length - 1][1] - d[d.length - 1][0] > 0.01; })
				.append("text")
				.attrs({
				"x": divWidthLessMargins - 6,
				"y": function(d) { return yScale((d[d.length - 1][0] + d[d.length - 1][1]) / 2); },
				"dy": ".35em",
				})
				.style("font", "10px sans-serif")
				.style("text-anchor", "end")
				.text(function(d) { return d.key; });


				xAxisG.call(xAxis)
				.selectAll('.tick line').attrs({
				'class':'xLine',
				'stroke-dasharray': '1, 5'
				});

				xAxisG.selectAll('.tick text')
				.attrs({
				'transform': 'rotate(-45)',
				'text-anchor': 'end',
				'alignment-baseline':'middle',
				'x': -5,
				'y': 15,
				'dy':0
				})

				yAxisG.call(yAxis)
				.selectAll('.tick line').attrs({
				'class':'yLine',
				'stroke-dasharray': '1, 5'
				});

			});

		}

	       let AllChartObj = {
	           svgClass: '.svgWrapper',
	           dataFile:'redata.json'
	       }
	       buildChart(AllChartObj);

	</script>
</body>
</html>