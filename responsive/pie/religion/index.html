</!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<script src="../../../d3.v4.min.js"></script>
		<script src="../../../d3-selection-multi.min.js"></script>
	    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.24.0/d3-legend.min.js"></script>
		<link rel="stylesheet" type="text/css" href="../../dark.css">
		<title>Religion World-Total Pie</title>
	</head>

	<body>
		<div id="chartDiv"></div>
	</body>    
	<script>

	      // const colorValue = d => d.TotalDeaths;
	      const colorValue = d => d.religion;
	      const colorLabel = 'Religion';
	      
	      const margin = { 
	      	left: 140, 
	      	right: 200,
	      	top: 20,
	      	bottom: 120
	      };

//Select/Create div, svg, g
	      const chartDiv = document.getElementById('chartDiv'); 	      
	      const svgObj = d3.select(chartDiv).append("svg").attrs({
	      	// "class":obj.svgClass,
	      	"border": '2px solid green'
	      });
	      const gObj = svgObj.append('g').attr('class','gWrapper');

//Setup Scales
	      const colorScale = d3.scaleOrdinal()
	        .range(d3.schemeCategory10);

// Extract the DIV width and height that was computed by CSS.
      let cssDivWidth = chartDiv.clientWidth;
      let cssDivHeight = chartDiv.clientHeight;

//get css-computed dimensions
	      const divWidthLessMargins =cssDivWidth - margin.left - margin.right;
	      const divHeightLessMargins = cssDivHeight - margin.top - margin.bottom;

//set svg height & width from div computed dimensions
//NOTE: can be the divLessMargins, for 'padding' effect
      svgObj.attrs({
        "width" : cssDivWidth,
        "height" : cssDivHeight
      });

//translate the gWrapper
      gObj.attr('transform', `translate(${margin.left},${margin.top})`);

//Build Axis Groups
	      const colorLegendG = gObj.append('g')
	          .attr('transform', `translate(${divWidthLessMargins + 60}, 150)`);

	      colorLegendG.append('text')
	          .attrs({
	          	'class': 'legend-label',
	          	'x': -3,
	          	'y': -40
	          })
	          .text(colorLabel);

	      const colorLegend = d3.legendColor()
	        .scale(colorScale)
	        .shape('circle');

	      const parseData = d => {
	      	d.population = +d.population;
	      	return d;
	      };

	    function buildChart(obj){

	      d3.csv(obj.dataFile, parseData, data => {

	        gObj.selectAll('circle').data(data)
	          .enter().append('circle')
	            .attrs({
	            	// 'cx': d => xScale(xValue(d)),
	            	// 'cy': d => yScale(yValue(d)),
	            	'fill': d => colorScale(colorValue(d)),
	            	'fill-opacity': 0.3,
	            	'r': 17,
	            	'class':'circle'
	            });

	        colorLegendG.call(colorLegend)
	          .selectAll('.cell text')
	            .attr('dy', '0.1em');
	      });

	  	}

	  	let AllChartObj = {
	  		svgClass: '.svgWrapper',
	  		dataFile:'data.csv'
	  	}
	  	buildChart(AllChartObj);

//2. Build fn
		let resize = () => {
    		
    		// Extract the width and height that was computed by CSS.
      		let resizedFnWidth = chartDiv.clientWidth;
      		let resizedFnHeight = chartDiv.clientHeight;

      		//set svg dimension based on resizing attrs
      		svgObj.attrs({
		        "width" : resizedFnWidth,
		        "height" : resizedFnHeight
	        });

	        //calc resized dimensions less margins
	        let resizedWidthLessMargins = resizedFnWidth - margin.left - margin.right;
      		let resizedHeightLessMargins = resizedFnHeight - margin.top - margin.bottom;


			//update Bubbles
			// d3.selectAll('.circle').attrs({
   //          	'cx': d => xScale(xValue(d)),
   //          	'cy': d => yScale(yValue(d))
			// });


        	colorLegendG
	          .attr('transform', `translate(${resizedWidthLessMargins + 60}, 150)`);	


		}	  	

//1. Add Resise listener & fn call
	  	d3.select(window).on('resize',resize);
	    </script>

</html>